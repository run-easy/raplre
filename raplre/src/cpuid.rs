#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(dead_code)]
#![allow(deref_nullptr)]

/* automatically generated by rust-bindgen 0.59.2 */

use std::{collections::HashMap, ptr::NonNull, sync::Mutex};

use errore::{
    error::RError,
    kind::{FFIERR, IOERR},
};
use once_cell::sync::Lazy;

#[link(name = "cpuid")]
extern "C" {
    // pub fn cpuid_get_raw_data(data: *mut cpu_raw_data_t) -> ::std::os::raw::c_int;
    pub fn cpuid_get_total_cpus() -> ::std::os::raw::c_int;
    // pub fn cpuid_lib_version() -> *const ::std::os::raw::c_char;
    // pub fn cpuid_present() -> ::std::os::raw::c_int;
    // pub fn cpu_identify(raw: *mut cpu_raw_data_t, data: *mut cpu_id_t) -> ::std::os::raw::c_int;
    pub fn cpuid_error() -> *const ::std::os::raw::c_char;
    pub fn cpu_msr_driver_open_core(core_num: ::std::os::raw::c_uint) -> *mut msr_driver_t;
    pub fn cpu_rdmsr(
        handle: *mut msr_driver_t,
        msr_index: u32,
        result: *mut u64,
    ) -> ::std::os::raw::c_int;
    pub fn cpu_msr_driver_close(handle: *mut msr_driver_t) -> ::std::os::raw::c_int;
}

#[inline]
fn cpuid_error_str() -> String {
    unsafe {
        std::ffi::CStr::from_ptr(cpuid_error() as *const _)
            .to_str()
            .unwrap()
            .to_string()
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msr_driver_t {
    _unused: [u8; 0],
}

static MSR_DRIVERS: Lazy<Mutex<HashMap<u32, MsrDriver>>> = Lazy::new(|| Mutex::new(HashMap::new()));

struct MsrDriver {
    inner: NonNull<msr_driver_t>,
}

unsafe impl Send for MsrDriver {}

impl MsrDriver {
    fn new(core: u32) -> Result<Self, RError> {
        let ptr = unsafe { cpu_msr_driver_open_core(core) };
        if ptr.is_null() {
            crate::throw_rerr!(
                FFIERR,
                "Failed to open msr driver at core {}. (error: {})",
                core,
                cpuid_error_str()
            );
        }

        Ok(Self {
            inner: NonNull::new(ptr).unwrap(),
        })
    }

    fn read(&mut self, which: u32) -> Result<u64, RError> {
        unsafe {
            let handle = self.inner.as_mut() as *mut _;
            let mut result: u64 = 0;
            let res = cpu_rdmsr(handle, which, &mut result as *mut _);
            if res != 0 {
                crate::throw_rerr!(
                    IOERR,
                    "Failed to read msr at {}. (error:{})",
                    which,
                    cpuid_error_str()
                );
            }
            Ok(result)
        }
    }
}

impl Drop for MsrDriver {
    fn drop(&mut self) {
        unsafe {
            let ptr = self.inner.as_mut() as *mut _;
            assert!(cpu_msr_driver_close(ptr) != 0);
        }
    }
}

pub(crate) fn read_msr(core: u32, which: u32) -> Result<u64, RError> {
    let mut msr_drivers = MSR_DRIVERS.lock().unwrap();
    if let Some(msr) = msr_drivers.get_mut(&core) {
        msr.read(which)
    } else {
        let mut msr = MsrDriver::new(core)?;
        let res = msr.read(which);
        msr_drivers.insert(core, msr);
        res
    }
}
