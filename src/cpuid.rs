#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(dead_code)]
#![allow(deref_nullptr)]

/* automatically generated by rust-bindgen 0.59.2 */

use std::{collections::HashMap, io::Read, ptr::NonNull, sync::Mutex};

use once_cell::sync::Lazy;
use run_error::{
    error::RError,
    kind::{FFIERR, IOERR, OSERR},
};

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub const cpu_vendor_t_VENDOR_INTEL: cpu_vendor_t = 0;
pub const cpu_vendor_t_VENDOR_AMD: cpu_vendor_t = 1;
pub const cpu_vendor_t_VENDOR_CYRIX: cpu_vendor_t = 2;
pub const cpu_vendor_t_VENDOR_NEXGEN: cpu_vendor_t = 3;
pub const cpu_vendor_t_VENDOR_TRANSMETA: cpu_vendor_t = 4;
pub const cpu_vendor_t_VENDOR_UMC: cpu_vendor_t = 5;
pub const cpu_vendor_t_VENDOR_CENTAUR: cpu_vendor_t = 6;
pub const cpu_vendor_t_VENDOR_RISE: cpu_vendor_t = 7;
pub const cpu_vendor_t_VENDOR_SIS: cpu_vendor_t = 8;
pub const cpu_vendor_t_VENDOR_NSC: cpu_vendor_t = 9;
pub const cpu_vendor_t_NUM_CPU_VENDORS: cpu_vendor_t = 10;
pub const cpu_vendor_t_VENDOR_UNKNOWN: cpu_vendor_t = -1;
pub type cpu_vendor_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_raw_data_t {
    pub basic_cpuid: [[u32; 4usize]; 32usize],
    pub ext_cpuid: [[u32; 4usize]; 32usize],
    pub intel_fn4: [[u32; 4usize]; 8usize],
    pub intel_fn11: [[u32; 4usize]; 4usize],
    pub intel_fn12h: [[u32; 4usize]; 4usize],
    pub intel_fn14h: [[u32; 4usize]; 4usize],
}
#[test]
fn bindgen_test_layout_cpu_raw_data_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_raw_data_t>(),
        1344usize,
        concat!("Size of: ", stringify!(cpu_raw_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_raw_data_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cpu_raw_data_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_raw_data_t>())).basic_cpuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_raw_data_t),
            "::",
            stringify!(basic_cpuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_raw_data_t>())).ext_cpuid as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_raw_data_t),
            "::",
            stringify!(ext_cpuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_raw_data_t>())).intel_fn4 as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_raw_data_t),
            "::",
            stringify!(intel_fn4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_raw_data_t>())).intel_fn11 as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_raw_data_t),
            "::",
            stringify!(intel_fn11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_raw_data_t>())).intel_fn12h as *const _ as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_raw_data_t),
            "::",
            stringify!(intel_fn12h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_raw_data_t>())).intel_fn14h as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_raw_data_t),
            "::",
            stringify!(intel_fn14h)
        )
    );
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_sgx_t {
    pub present: u32,
    pub max_enclave_32bit: u8,
    pub max_enclave_64bit: u8,
    pub flags: [u8; 14usize],
    pub num_epc_sections: ::std::os::raw::c_int,
    pub misc_select: u32,
    pub secs_attributes: u64,
    pub secs_xfrm: u64,
}

#[test]
fn bindgen_test_layout_cpu_sgx_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_sgx_t>(),
        48usize,
        concat!("Size of: ", stringify!(cpu_sgx_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_sgx_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_sgx_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_sgx_t>())).present as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_sgx_t),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_sgx_t>())).max_enclave_32bit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_sgx_t),
            "::",
            stringify!(max_enclave_32bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_sgx_t>())).max_enclave_64bit as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_sgx_t),
            "::",
            stringify!(max_enclave_64bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_sgx_t>())).flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_sgx_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_sgx_t>())).num_epc_sections as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_sgx_t),
            "::",
            stringify!(num_epc_sections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_sgx_t>())).misc_select as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_sgx_t),
            "::",
            stringify!(misc_select)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_sgx_t>())).secs_attributes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_sgx_t),
            "::",
            stringify!(secs_attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_sgx_t>())).secs_xfrm as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_sgx_t),
            "::",
            stringify!(secs_xfrm)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_id_t {
    pub vendor_str: [::std::os::raw::c_char; 16usize],
    pub brand_str: [::std::os::raw::c_char; 64usize],
    pub vendor: cpu_vendor_t,
    pub flags: [u8; 128usize],
    pub family: i32,
    pub model: i32,
    pub stepping: i32,
    pub ext_family: i32,
    pub ext_model: i32,
    pub num_cores: i32,
    pub num_logical_cpus: i32,
    pub total_logical_cpus: i32,
    pub l1_data_cache: i32,
    pub l1_instruction_cache: i32,
    pub l2_cache: i32,
    pub l3_cache: i32,
    pub l4_cache: i32,
    pub l1_assoc: i32,
    pub l2_assoc: i32,
    pub l3_assoc: i32,
    pub l4_assoc: i32,
    pub l1_cacheline: i32,
    pub l2_cacheline: i32,
    pub l3_cacheline: i32,
    pub l4_cacheline: i32,
    pub cpu_codename: [::std::os::raw::c_char; 64usize],
    pub sse_size: i32,
    pub detection_hints: [u8; 16usize],
    pub sgx: cpu_sgx_t,
}

#[test]
fn bindgen_test_layout_cpu_id_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_id_t>(),
        432usize,
        concat!("Size of: ", stringify!(cpu_id_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_id_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_id_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).vendor_str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(vendor_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).brand_str as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(brand_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).vendor as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).flags as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).family as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).model as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).stepping as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(stepping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).ext_family as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(ext_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).ext_model as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(ext_model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).num_cores as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(num_cores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).num_logical_cpus as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(num_logical_cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).total_logical_cpus as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(total_logical_cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l1_data_cache as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l1_data_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l1_instruction_cache as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l1_instruction_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l2_cache as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l2_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l3_cache as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l3_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l4_cache as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l4_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l1_assoc as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l1_assoc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l2_assoc as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l2_assoc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l3_assoc as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l3_assoc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l4_assoc as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l4_assoc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l1_cacheline as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l1_cacheline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l2_cacheline as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l2_cacheline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l3_cacheline as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l3_cacheline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).l4_cacheline as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(l4_cacheline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).cpu_codename as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(cpu_codename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).sse_size as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(sse_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).detection_hints as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(detection_hints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_id_t>())).sgx as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_id_t),
            "::",
            stringify!(sgx)
        )
    );
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msr_driver_t {
    _unused: [u8; 0],
}

#[link(name = "cpuid")]
extern "C" {
    pub fn cpuid_get_raw_data(data: *mut cpu_raw_data_t) -> ::std::os::raw::c_int;
    pub fn cpuid_get_total_cpus() -> ::std::os::raw::c_int;
    pub fn cpuid_lib_version() -> *const ::std::os::raw::c_char;
    pub fn cpuid_present() -> ::std::os::raw::c_int;
    pub fn cpu_identify(raw: *mut cpu_raw_data_t, data: *mut cpu_id_t) -> ::std::os::raw::c_int;
    pub fn cpuid_error() -> *const ::std::os::raw::c_char;
    pub fn cpu_msr_driver_open_core(core_num: ::std::os::raw::c_uint) -> *mut msr_driver_t;
    pub fn cpu_rdmsr(
        handle: *mut msr_driver_t,
        msr_index: u32,
        result: *mut u64,
    ) -> ::std::os::raw::c_int;
    pub fn cpu_msr_driver_close(handle: *mut msr_driver_t) -> ::std::os::raw::c_int;
}

pub fn cpuid_get_raw_data_core(core: u32) -> Result<cpu_raw_data_t, RError> {
    let th = std::thread::spawn(move || {
        unsafe {
            /*
             * The pthread_setaffinity_np() function sets the CPU affinity mask
             * of the thread thread to the CPU set pointed to by cpuset.  If the
             * call is successful, and the thread is not currently running on
             * one of the CPUs in cpuset, then it is migrated to one of those CPUs
             */
            let mut cpuset: libc::cpu_set_t = std::mem::zeroed();
            libc::CPU_ZERO(&mut cpuset);
            libc::CPU_SET(core as usize, &mut cpuset);
            let res = libc::pthread_setaffinity_np(
                libc::pthread_self(),
                libc::CPU_SETSIZE as libc::size_t,
                &mut cpuset as *mut _,
            );
            if res != 0 {
                crate::throw_rerr!(OSERR, "Failed to set pthread affinity at {}", core);
            }

            // Get cpuid information
            let mut raw_cpu_data: crate::cpuid::cpu_raw_data_t = std::mem::zeroed();
            let res = crate::cpuid::cpuid_get_raw_data(&mut raw_cpu_data as *mut _);
            if res != 0 {
                crate::throw_rerr!(
                    FFIERR,
                    "Failed to get cpu_raw_data. (error: {})",
                    std::ffi::CStr::from_ptr(crate::cpuid::cpuid_error() as *const _)
                        .to_str()
                        .unwrap()
                );
            }

            Ok(raw_cpu_data)
        }
    });

    th.join().unwrap()
}

const MAX_NUM_CORES: usize = 1024;
const MAX_NUM_PACKAGES: usize = 16;
static NUM_PACKAGE: Lazy<u32> = Lazy::new(|| {
    let mut num_packages = 0;
    for core in 0..MAX_NUM_CORES {
        let path = std::path::PathBuf::from(format!(
            "/sys/bus/cpu/devices/cpu{}/topology/physical_package_id",
            core
        ));

        if !path.exists() {
            continue;
        }

        match std::fs::File::open(&path) {
            Ok(mut f) => {
                let mut pkg_id_str = String::new();
                if let Err(e) = f.read_to_string(&mut pkg_id_str) {
                    log::error!(
                        "Failed to read {} (error:{}).",
                        path.as_os_str().to_str().unwrap(),
                        e
                    );
                    std::process::exit(1);
                }
                let pkg_id: u32 = pkg_id_str.trim().parse().unwrap();
                if pkg_id > num_packages {
                    num_packages = pkg_id;
                }
            }
            Err(e) => {
                log::error!(
                    "Failed to open {} (error:{}).",
                    path.as_os_str().to_str().unwrap(),
                    e
                );
                std::process::exit(1);
            }
        }
    }

    num_packages + 1
});
static PKG_MAP: Lazy<HashMap<u32, CpuInfo>> = Lazy::new(|| pkg_map_init());

fn pkg_map_init() -> HashMap<u32, CpuInfo> {
    let mut res = HashMap::new();
    for pkg in 0..num_package() {
        let cpu_info = CpuInfo::new(pkg).unwrap();
        res.insert(pkg, cpu_info);
    }

    res
}

pub(crate) fn num_package() -> u32 {
    *NUM_PACKAGE
}

pub(crate) fn get_core_of_package(package: u32) -> Option<u32> {
    for core in 0..MAX_NUM_CORES {
        let path = std::path::PathBuf::from(format!(
            "/sys/bus/cpu/devices/cpu{}/topology/physical_package_id",
            core
        ));

        if !path.exists() {
            continue;
        }

        match std::fs::File::open(&path) {
            Ok(mut f) => {
                let mut pkg_id_str = String::new();
                if let Err(e) = f.read_to_string(&mut pkg_id_str) {
                    log::error!(
                        "Failed to read {}: {}.",
                        path.as_os_str().to_str().unwrap(),
                        e
                    );
                    std::process::exit(1);
                }
                let pkg_id: u32 = pkg_id_str.trim().parse().unwrap();
                if pkg_id == package {
                    return Some(core as u32);
                }
            }
            Err(e) => {
                log::error!(
                    "Failed to open {} (error:{}).",
                    path.as_os_str().to_str().unwrap(),
                    e
                );
                std::process::exit(1);
            }
        }
    }

    None
}

#[derive(Debug, Clone)]
pub(crate) struct CpuInfo {
    pub(crate) package: u32,
    pub(crate) display_family: u32,
    pub(crate) display_model: u32,
    pub(crate) vendor_name: String,
    pub(crate) vendor: u32,
}

impl CpuInfo {
    fn new(package: u32) -> Result<Self, RError> {
        if package >= num_package() {
            crate::throw_rerr!(crate::INVALID_VALUE, "Invalid package id {}", package);
        }
        let core = get_core_of_package(package).unwrap();
        let mut raw_cpu_data = cpuid_get_raw_data_core(core)?;
        let mut cpu_id: cpu_id_t = unsafe { std::mem::zeroed() };
        unsafe {
            let res = cpu_identify(&mut raw_cpu_data as *mut _, &mut cpu_id as *mut cpu_id_t);
            if res != 0 {
                crate::throw_rerr!(
                    crate::FFIERR,
                    "Failed to identify cpu {} (error:{})",
                    package,
                    std::ffi::CStr::from_ptr(cpuid_error() as *const _)
                        .to_str()
                        .unwrap()
                );
            }

            Ok(Self {
                package: package,
                display_family: cpu_id.ext_family as u32,
                display_model: cpu_id.ext_model as u32,
                vendor: cpu_id.vendor as u32,
                vendor_name: std::ffi::CStr::from_ptr(cpu_id.vendor_str.as_ptr() as *const _)
                    .to_str()
                    .unwrap()
                    .to_string(),
            })
        }
    }
}

pub(crate) fn get_cpu_info(pkg: u32) -> Option<&'static CpuInfo> {
    PKG_MAP.get(&pkg)
}

#[inline]
fn cpuid_error_str() -> String {
    unsafe {
        std::ffi::CStr::from_ptr(cpuid_error() as *const _)
            .to_str()
            .unwrap()
            .to_string()
    }
}

static MSR_DRIVERS: Lazy<Mutex<HashMap<u32, MsrDriver>>> = Lazy::new(|| Mutex::new(HashMap::new()));

struct MsrDriver {
    inner: NonNull<msr_driver_t>,
}

unsafe impl Send for MsrDriver {}

impl MsrDriver {
    fn new(core: u32) -> Result<Self, RError> {
        let ptr = unsafe { cpu_msr_driver_open_core(core) };
        if ptr.is_null() {
            crate::throw_rerr!(
                FFIERR,
                "Failed to open msr driver at core {}. (error: {})",
                core,
                cpuid_error_str()
            );
        }

        Ok(Self {
            inner: NonNull::new(ptr).unwrap(),
        })
    }

    fn read(&mut self, which: u32) -> Result<u64, RError> {
        unsafe {
            let handle = self.inner.as_mut() as *mut _;
            let mut result: u64 = 0;
            let res = cpu_rdmsr(handle, which, &mut result as *mut _);
            if res != 0 {
                crate::throw_rerr!(
                    IOERR,
                    "Failed to read msr at {}. (error:{})",
                    which,
                    cpuid_error_str()
                );
            }
            Ok(result)
        }
    }
}

impl Drop for MsrDriver {
    fn drop(&mut self) {
        unsafe {
            let ptr = self.inner.as_mut() as *mut _;
            assert!(cpu_msr_driver_close(ptr) != 0);
        }
    }
}

pub(crate) fn read_msr(core: u32, which: u32) -> Result<u64, RError> {
    let mut msr_drivers = MSR_DRIVERS.lock().unwrap();
    if let Some(msr) = msr_drivers.get_mut(&core) {
        msr.read(which)
    } else {
        let mut msr = MsrDriver::new(core)?;
        let res = msr.read(which);
        msr_drivers.insert(core, msr);
        res
    }
}
